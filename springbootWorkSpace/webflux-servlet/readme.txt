webfulx web 反应式 流编程
    Spring WebFlux 是一个自底向上构建的非阻塞Web框架，
    用于利用多核下一代处理器并发处理大量并发链接。

    浏览器-》servlet-》业务层
    注：针对于同步的servlet来说 ，大量并发下请求就会阻塞在
    servlet上，而servlet的并发量不大，就会限制服务器的吞吐量
    目的就是为了让servlet只用于接收请求 和 响应，其它耗时的
    操作交给业务层


WebFlux下应用的技术
    1.异步servlet（一般使用的是同步servlet）
        同步Servlet阻塞了什么
            档请求叨叨Tomcat后，Tomcat会为其找到与该请求相匹配的Servlet
            并分配一个该Servlet的线程处理请求。当Servlet中需要处理耗时
            操作时，当前Servlet线程会被阻塞。所以当前Servlet中的业务逻辑
            足额色了当前Servlet线程的执行

        异步Servlet是怎样工作的
            异步Servlet没有阻塞Servlet线程，而是很快结束了Servlet线程的调用
            将其有放入到了Servlet线程池，供其它请求使用。这样就增加了Tomcat
            服务器的吞吐量了
            不过需要注意一点，税软没有阻塞Servlet线程的运行，但是服务器想客户端
            的响应需要业务逻辑线程执行完毕后才会想客户端响应的。即对于客户端的
            用户体验来说，并没有感觉到服务器运算速度的加快，但服务器的吞吐量
            增加了。

    2.sse通信协议
        反应式流编程中 经常与SSE相结合使用
        老的http协议是请求-响应式的，即客户端提交一个请求，服务端只会给出一个
        响应。但对于某些实时性要求比较高的需求，若使用这种原理的请求-响应方式
        实现起来是比较麻烦的。HTML5标准中新增了一个SSE（Server-Sent Event ，
        服务端推送事件），可以方便地做到消息实时推送，即一次请求后悔不断的获得
        多个响应。由于这是官方特性，主流浏览器对其支持是较好的（除了火狐）

        通信协议
        这个通讯协议是基于纯文本的简单协议。服务端的响应内容类型必须是“text/event-stream"
        响应文本的内容是一个事件流，事件流是一个简单的文本流，仅支持UTF-8格式的编码。
        事件流由于不同的事件组成。不同事件间通过仅包含回车符合换行符的空行（“\r\n”）来分隔
        每个时间可以有多行构成，每行由类型和数据两部分组成。类型与数据通过冒号（“：”）进行
        分隔，冒号前的为类型，冒号后的为其对应的值。每个时间可以包含如下类型的行：
        * 类型为空白，表示改行是注释，会在处理时被忽略。
        * 类型为data,表示该行是事件所包含的数据。以data开头的行可以出现多次。
          所有这些行都是该事件的数据。
        * 类型为event,表示该行用来声明事件的类型，即事件名称。浏览器在收到数据时，会产生
            对应名称的事件。
        * 类型为id,表示该行用来声明事件的标识符。
        * 类型为retry,表示该行用来声明浏览器在链接断开之后进行重连的等待时间。

        事件标识id有什么用呢？
        如果服务端发送的事件中包含事件标识id，那么浏览器会将最近一次接受到的事件标识
        id记录到HTTP头的Last-Event-ID 属性中。如果浏览器与服务端的链接中断，当浏览器
        再次连接时，会将Last-Event-ID记录的事件标识id发送给服务端。服务器端通过浏览器
        端发送的事件标识id来确定将继续链接那个事件。
    3.反应式流编程
        Reactive Stream 概述
            （1） 推拉模型与背压
                在流处理机制中，push（推送）模型和 pull（拉取）模型是最常见的。push 模型中，
                发 布者将元素主动推送给订阅者。而 pull 模式中，订阅者会向发布者主动索要。
                在同步式系统 中发布者与订阅者的工作效率相当，发布者发布一个消息后阻塞，
                等待订阅者消费。订阅者 消费完后，订阅者阻塞，等待发布者发布。这种同步式处理方式效率很低。
                一般使用的是异 步消息处理机制。即发布者发布消息，与消费者消费消息的速度是不一样的。
                那么它们间是 如何协调工作的呢？ 当订阅者比发布者快时，会出现订阅者无消息可消费的情况。
                在同步数据处理机制中订 阅者需无限期等待，直到有消息可用。但在异步处理机制中，
                订阅者无需阻塞，其继续处理 其他任务即可。当出现了准备就绪的消息时，
                发布者会将它们异步发送给订阅者。所以，在 异步处理机制中，
                这种情况并不会对系统性能产生负面影响。 当发布者比订阅者快时，有两大类解决方案。
                一类解决方案是改变订阅者。要么使订阅者拥有一个无边界缓冲区来保存快速传入的消 息，
                要么让订阅者将它无法处理的消息丢弃。 另一类解决方案是改变发布者。这类解决方案采用的策略称为
                背压（Back Pressure）策 略。订阅者告诉发布者让其减慢发布速度并保持消息，直到订阅者准备好处理
                更多消息。使 用背压策略可确保较快的发布者不会压制较慢的订阅者。但该解决方案要求发布者要拥有无
                 限制缓冲区，以确保发布者可以一直生产和保存消息。当然，发布者也可以实现有界缓冲区 以保存有限
                 数量的消息。但若缓冲区满，则需要放弃这些消息。不过，可以让发布者将放弃 的消息再发布，
                 直到订阅将其消费。
            （2） 反应式流
                反应式流从 2013 年开始，作为提供非阻塞背压的异步流处理标准的倡议，
                旨在解决处 理元素流（即消息流、数据流）的问题——如何将元素流从发布者传递到订阅者，
                而不需要 发布者阻塞，或订阅者有无限制的缓冲区或丢弃。
                反应式流模型非常简单：订阅者向发布者发送多个元素的异步请求，发布者向订阅者异 步发送多个或稍少的元素。
                反应式流会在 pull 模型和 push 模型流处理机制之间动态切换。 当发布者快、订阅者慢时，它使用 pull 模型；
                当发布者慢、订阅者快时，它使用 push 模型。 即谁慢谁占主动。
                2015 年出版了用于处理反应式流的规范和 Java API

        反应式流接口
        1.Publisher<T>接口
            Publisher,即发布者，是有序消息的生产者。它根据收到的请求向订阅者发布消息
        2.Subscriber<T>接口
            Subscriber,即订阅者，从发布者哪里订阅并接收消息。发布者向订阅者发送订阅令牌（Subscription）
            。使用订阅令牌，订阅者可以从发布者哪里请求多个消息。当消息元素准备就绪时，发布者向订阅者发
            送多个或更少的元素。让后订阅者可以再次请求更多的消息元素，或取消订阅。一个发布者可能需要处理
            来自多个订阅者的请求。

        3 Subscription 接口
            Subscription(订阅费)，订阅令牌。当订阅请求成功时，发布者将其传递给订阅者。订阅者
            使用订阅令牌与发布者进行交互，例如请求更多的消息元素或取消订阅。

        4.Processor<T,R>
            Processor ，即处理器，充当订阅者和发布者的处理阶段。Processor 接口继承了
            Publisher 和 Subscriber 接口。它用于转换发布者/订阅者管道中的元素。Processor<T,R>
            会将来自于发布者的T类型的消息数据，接收并转换为R类型的数据，并将转换后的R类型数据
            发布给订阅者。一个发布者可以拥有多个处理者。